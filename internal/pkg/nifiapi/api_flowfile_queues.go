/*
NiFi Rest API

The Rest API provides programmatic access to command and control a NiFi instance in real time. Start and                                             stop processors, monitor queues, query provenance data, and more. Each endpoint below includes a description,                                             definitions of the expected input and output, potential response codes, and the authorizations required                                             to invoke each service.

API version: 2.0.0
Contact: dev@nifi.apache.org
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package nifiapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// FlowfileQueuesAPIService FlowfileQueuesAPI service
type FlowfileQueuesAPIService service

type FlowfileQueuesAPICreateDropRequestRequest struct {
	ctx context.Context
	ApiService *FlowfileQueuesAPIService
	id string
}

func (r FlowfileQueuesAPICreateDropRequestRequest) Execute() (*DropRequestEntity, *http.Response, error) {
	return r.ApiService.CreateDropRequestExecute(r)
}

/*
CreateDropRequest Creates a request to drop the contents of the queue in this connection.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The connection id.
 @return FlowfileQueuesAPICreateDropRequestRequest
*/
func (a *FlowfileQueuesAPIService) CreateDropRequest(ctx context.Context, id string) FlowfileQueuesAPICreateDropRequestRequest {
	return FlowfileQueuesAPICreateDropRequestRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DropRequestEntity
func (a *FlowfileQueuesAPIService) CreateDropRequestExecute(r FlowfileQueuesAPICreateDropRequestRequest) (*DropRequestEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DropRequestEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowfileQueuesAPIService.CreateDropRequest")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flowfile-queues/{id}/drop-requests"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowfileQueuesAPICreateFlowFileListingRequest struct {
	ctx context.Context
	ApiService *FlowfileQueuesAPIService
	id string
}

func (r FlowfileQueuesAPICreateFlowFileListingRequest) Execute() (*ListingRequestEntity, *http.Response, error) {
	return r.ApiService.CreateFlowFileListingExecute(r)
}

/*
CreateFlowFileListing Lists the contents of the queue in this connection.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The connection id.
 @return FlowfileQueuesAPICreateFlowFileListingRequest
*/
func (a *FlowfileQueuesAPIService) CreateFlowFileListing(ctx context.Context, id string) FlowfileQueuesAPICreateFlowFileListingRequest {
	return FlowfileQueuesAPICreateFlowFileListingRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ListingRequestEntity
func (a *FlowfileQueuesAPIService) CreateFlowFileListingExecute(r FlowfileQueuesAPICreateFlowFileListingRequest) (*ListingRequestEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListingRequestEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowfileQueuesAPIService.CreateFlowFileListing")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flowfile-queues/{id}/listing-requests"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowfileQueuesAPIDeleteListingRequestRequest struct {
	ctx context.Context
	ApiService *FlowfileQueuesAPIService
	id string
	listingRequestId string
}

func (r FlowfileQueuesAPIDeleteListingRequestRequest) Execute() (*ListingRequestEntity, *http.Response, error) {
	return r.ApiService.DeleteListingRequestExecute(r)
}

/*
DeleteListingRequest Cancels and/or removes a request to list the contents of this connection.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The connection id.
 @param listingRequestId The listing request id.
 @return FlowfileQueuesAPIDeleteListingRequestRequest
*/
func (a *FlowfileQueuesAPIService) DeleteListingRequest(ctx context.Context, id string, listingRequestId string) FlowfileQueuesAPIDeleteListingRequestRequest {
	return FlowfileQueuesAPIDeleteListingRequestRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		listingRequestId: listingRequestId,
	}
}

// Execute executes the request
//  @return ListingRequestEntity
func (a *FlowfileQueuesAPIService) DeleteListingRequestExecute(r FlowfileQueuesAPIDeleteListingRequestRequest) (*ListingRequestEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListingRequestEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowfileQueuesAPIService.DeleteListingRequest")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flowfile-queues/{id}/listing-requests/{listing-request-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listing-request-id"+"}", url.PathEscape(parameterValueToString(r.listingRequestId, "listingRequestId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowfileQueuesAPIDownloadFlowFileContentRequest struct {
	ctx context.Context
	ApiService *FlowfileQueuesAPIService
	id string
	flowfileUuid string
	clientId *string
	clusterNodeId *string
}

// If the client id is not specified, new one will be generated. This value (whether specified or generated) is included in the response.
func (r FlowfileQueuesAPIDownloadFlowFileContentRequest) ClientId(clientId string) FlowfileQueuesAPIDownloadFlowFileContentRequest {
	r.clientId = &clientId
	return r
}

// The id of the node where the content exists if clustered.
func (r FlowfileQueuesAPIDownloadFlowFileContentRequest) ClusterNodeId(clusterNodeId string) FlowfileQueuesAPIDownloadFlowFileContentRequest {
	r.clusterNodeId = &clusterNodeId
	return r
}

func (r FlowfileQueuesAPIDownloadFlowFileContentRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DownloadFlowFileContentExecute(r)
}

/*
DownloadFlowFileContent Gets the content for a FlowFile in a Connection.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The connection id.
 @param flowfileUuid The flowfile uuid.
 @return FlowfileQueuesAPIDownloadFlowFileContentRequest
*/
func (a *FlowfileQueuesAPIService) DownloadFlowFileContent(ctx context.Context, id string, flowfileUuid string) FlowfileQueuesAPIDownloadFlowFileContentRequest {
	return FlowfileQueuesAPIDownloadFlowFileContentRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		flowfileUuid: flowfileUuid,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *FlowfileQueuesAPIService) DownloadFlowFileContentExecute(r FlowfileQueuesAPIDownloadFlowFileContentRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowfileQueuesAPIService.DownloadFlowFileContent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flowfile-queues/{id}/flowfiles/{flowfile-uuid}/content"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"flowfile-uuid"+"}", url.PathEscape(parameterValueToString(r.flowfileUuid, "flowfileUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.clientId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clientId", r.clientId, "")
	}
	if r.clusterNodeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clusterNodeId", r.clusterNodeId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowfileQueuesAPIGetDropRequestRequest struct {
	ctx context.Context
	ApiService *FlowfileQueuesAPIService
	id string
	dropRequestId string
}

func (r FlowfileQueuesAPIGetDropRequestRequest) Execute() (*DropRequestEntity, *http.Response, error) {
	return r.ApiService.GetDropRequestExecute(r)
}

/*
GetDropRequest Gets the current status of a drop request for the specified connection.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The connection id.
 @param dropRequestId The drop request id.
 @return FlowfileQueuesAPIGetDropRequestRequest
*/
func (a *FlowfileQueuesAPIService) GetDropRequest(ctx context.Context, id string, dropRequestId string) FlowfileQueuesAPIGetDropRequestRequest {
	return FlowfileQueuesAPIGetDropRequestRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		dropRequestId: dropRequestId,
	}
}

// Execute executes the request
//  @return DropRequestEntity
func (a *FlowfileQueuesAPIService) GetDropRequestExecute(r FlowfileQueuesAPIGetDropRequestRequest) (*DropRequestEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DropRequestEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowfileQueuesAPIService.GetDropRequest")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flowfile-queues/{id}/drop-requests/{drop-request-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"drop-request-id"+"}", url.PathEscape(parameterValueToString(r.dropRequestId, "dropRequestId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowfileQueuesAPIGetFlowFileRequest struct {
	ctx context.Context
	ApiService *FlowfileQueuesAPIService
	id string
	flowfileUuid string
	clusterNodeId *string
}

// The id of the node where the content exists if clustered.
func (r FlowfileQueuesAPIGetFlowFileRequest) ClusterNodeId(clusterNodeId string) FlowfileQueuesAPIGetFlowFileRequest {
	r.clusterNodeId = &clusterNodeId
	return r
}

func (r FlowfileQueuesAPIGetFlowFileRequest) Execute() (*FlowFileEntity, *http.Response, error) {
	return r.ApiService.GetFlowFileExecute(r)
}

/*
GetFlowFile Gets a FlowFile from a Connection.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The connection id.
 @param flowfileUuid The flowfile uuid.
 @return FlowfileQueuesAPIGetFlowFileRequest
*/
func (a *FlowfileQueuesAPIService) GetFlowFile(ctx context.Context, id string, flowfileUuid string) FlowfileQueuesAPIGetFlowFileRequest {
	return FlowfileQueuesAPIGetFlowFileRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		flowfileUuid: flowfileUuid,
	}
}

// Execute executes the request
//  @return FlowFileEntity
func (a *FlowfileQueuesAPIService) GetFlowFileExecute(r FlowfileQueuesAPIGetFlowFileRequest) (*FlowFileEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FlowFileEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowfileQueuesAPIService.GetFlowFile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flowfile-queues/{id}/flowfiles/{flowfile-uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"flowfile-uuid"+"}", url.PathEscape(parameterValueToString(r.flowfileUuid, "flowfileUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.clusterNodeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clusterNodeId", r.clusterNodeId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowfileQueuesAPIGetListingRequestRequest struct {
	ctx context.Context
	ApiService *FlowfileQueuesAPIService
	id string
	listingRequestId string
}

func (r FlowfileQueuesAPIGetListingRequestRequest) Execute() (*ListingRequestEntity, *http.Response, error) {
	return r.ApiService.GetListingRequestExecute(r)
}

/*
GetListingRequest Gets the current status of a listing request for the specified connection.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The connection id.
 @param listingRequestId The listing request id.
 @return FlowfileQueuesAPIGetListingRequestRequest
*/
func (a *FlowfileQueuesAPIService) GetListingRequest(ctx context.Context, id string, listingRequestId string) FlowfileQueuesAPIGetListingRequestRequest {
	return FlowfileQueuesAPIGetListingRequestRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		listingRequestId: listingRequestId,
	}
}

// Execute executes the request
//  @return ListingRequestEntity
func (a *FlowfileQueuesAPIService) GetListingRequestExecute(r FlowfileQueuesAPIGetListingRequestRequest) (*ListingRequestEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListingRequestEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowfileQueuesAPIService.GetListingRequest")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flowfile-queues/{id}/listing-requests/{listing-request-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listing-request-id"+"}", url.PathEscape(parameterValueToString(r.listingRequestId, "listingRequestId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowfileQueuesAPIRemoveDropRequestRequest struct {
	ctx context.Context
	ApiService *FlowfileQueuesAPIService
	id string
	dropRequestId string
}

func (r FlowfileQueuesAPIRemoveDropRequestRequest) Execute() (*DropRequestEntity, *http.Response, error) {
	return r.ApiService.RemoveDropRequestExecute(r)
}

/*
RemoveDropRequest Cancels and/or removes a request to drop the contents of this connection.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The connection id.
 @param dropRequestId The drop request id.
 @return FlowfileQueuesAPIRemoveDropRequestRequest
*/
func (a *FlowfileQueuesAPIService) RemoveDropRequest(ctx context.Context, id string, dropRequestId string) FlowfileQueuesAPIRemoveDropRequestRequest {
	return FlowfileQueuesAPIRemoveDropRequestRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		dropRequestId: dropRequestId,
	}
}

// Execute executes the request
//  @return DropRequestEntity
func (a *FlowfileQueuesAPIService) RemoveDropRequestExecute(r FlowfileQueuesAPIRemoveDropRequestRequest) (*DropRequestEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DropRequestEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowfileQueuesAPIService.RemoveDropRequest")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flowfile-queues/{id}/drop-requests/{drop-request-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"drop-request-id"+"}", url.PathEscape(parameterValueToString(r.dropRequestId, "dropRequestId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
