/*
NiFi Rest API

The Rest API provides programmatic access to command and control a NiFi instance in real time. Start and                                             stop processors, monitor queues, query provenance data, and more. Each endpoint below includes a description,                                             definitions of the expected input and output, potential response codes, and the authorizations required                                             to invoke each service.

API version: 2.0.0
Contact: dev@nifi.apache.org
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package nifiapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// FlowAPIService FlowAPI service
type FlowAPIService service

type FlowAPIActivateControllerServicesRequest struct {
	ctx context.Context
	ApiService *FlowAPIService
	id string
	body *ActivateControllerServicesEntity
}

// The request to schedule or unschedule. If the comopnents in the request are not specified, all authorized components will be considered.
func (r FlowAPIActivateControllerServicesRequest) Body(body ActivateControllerServicesEntity) FlowAPIActivateControllerServicesRequest {
	r.body = &body
	return r
}

func (r FlowAPIActivateControllerServicesRequest) Execute() (*ActivateControllerServicesEntity, *http.Response, error) {
	return r.ApiService.ActivateControllerServicesExecute(r)
}

/*
ActivateControllerServices Enable or disable Controller Services in the specified Process Group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The process group id.
 @return FlowAPIActivateControllerServicesRequest
*/
func (a *FlowAPIService) ActivateControllerServices(ctx context.Context, id string) FlowAPIActivateControllerServicesRequest {
	return FlowAPIActivateControllerServicesRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ActivateControllerServicesEntity
func (a *FlowAPIService) ActivateControllerServicesExecute(r FlowAPIActivateControllerServicesRequest) (*ActivateControllerServicesEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActivateControllerServicesEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowAPIService.ActivateControllerServices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/process-groups/{id}/controller-services"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowAPIGenerateClientIdRequest struct {
	ctx context.Context
	ApiService *FlowAPIService
}

func (r FlowAPIGenerateClientIdRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.GenerateClientIdExecute(r)
}

/*
GenerateClientId Generates a client id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FlowAPIGenerateClientIdRequest
*/
func (a *FlowAPIService) GenerateClientId(ctx context.Context) FlowAPIGenerateClientIdRequest {
	return FlowAPIGenerateClientIdRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *FlowAPIService) GenerateClientIdExecute(r FlowAPIGenerateClientIdRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowAPIService.GenerateClientId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/client-id"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowAPIGetAboutInfoRequest struct {
	ctx context.Context
	ApiService *FlowAPIService
}

func (r FlowAPIGetAboutInfoRequest) Execute() (*AboutEntity, *http.Response, error) {
	return r.ApiService.GetAboutInfoExecute(r)
}

/*
GetAboutInfo Retrieves details about this NiFi to put in the About dialog

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FlowAPIGetAboutInfoRequest
*/
func (a *FlowAPIService) GetAboutInfo(ctx context.Context) FlowAPIGetAboutInfoRequest {
	return FlowAPIGetAboutInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AboutEntity
func (a *FlowAPIService) GetAboutInfoExecute(r FlowAPIGetAboutInfoRequest) (*AboutEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AboutEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowAPIService.GetAboutInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/about"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowAPIGetActionRequest struct {
	ctx context.Context
	ApiService *FlowAPIService
	id string
}

func (r FlowAPIGetActionRequest) Execute() (*ActionEntity, *http.Response, error) {
	return r.ApiService.GetActionExecute(r)
}

/*
GetAction Gets an action

Note: This endpoint is subject to change as NiFi and it's REST API evolve.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The action id.
 @return FlowAPIGetActionRequest
*/
func (a *FlowAPIService) GetAction(ctx context.Context, id string) FlowAPIGetActionRequest {
	return FlowAPIGetActionRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ActionEntity
func (a *FlowAPIService) GetActionExecute(r FlowAPIGetActionRequest) (*ActionEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowAPIService.GetAction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/history/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowAPIGetBannersRequest struct {
	ctx context.Context
	ApiService *FlowAPIService
}

func (r FlowAPIGetBannersRequest) Execute() (*BannerEntity, *http.Response, error) {
	return r.ApiService.GetBannersExecute(r)
}

/*
GetBanners Retrieves the banners for this NiFi

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FlowAPIGetBannersRequest
*/
func (a *FlowAPIService) GetBanners(ctx context.Context) FlowAPIGetBannersRequest {
	return FlowAPIGetBannersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BannerEntity
func (a *FlowAPIService) GetBannersExecute(r FlowAPIGetBannersRequest) (*BannerEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BannerEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowAPIService.GetBanners")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/banners"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowAPIGetBucketsRequest struct {
	ctx context.Context
	ApiService *FlowAPIService
	id string
}

func (r FlowAPIGetBucketsRequest) Execute() (*FlowRegistryBucketsEntity, *http.Response, error) {
	return r.ApiService.GetBucketsExecute(r)
}

/*
GetBuckets Gets the buckets from the specified registry for the current user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The registry id.
 @return FlowAPIGetBucketsRequest
*/
func (a *FlowAPIService) GetBuckets(ctx context.Context, id string) FlowAPIGetBucketsRequest {
	return FlowAPIGetBucketsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FlowRegistryBucketsEntity
func (a *FlowAPIService) GetBucketsExecute(r FlowAPIGetBucketsRequest) (*FlowRegistryBucketsEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FlowRegistryBucketsEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowAPIService.GetBuckets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/registries/{id}/buckets"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowAPIGetBulletinBoardRequest struct {
	ctx context.Context
	ApiService *FlowAPIService
	after *string
	sourceName *string
	message *string
	sourceId *string
	groupId *string
	limit *string
}

// Includes bulletins with an id after this value.
func (r FlowAPIGetBulletinBoardRequest) After(after string) FlowAPIGetBulletinBoardRequest {
	r.after = &after
	return r
}

// Includes bulletins originating from this sources whose name match this regular expression.
func (r FlowAPIGetBulletinBoardRequest) SourceName(sourceName string) FlowAPIGetBulletinBoardRequest {
	r.sourceName = &sourceName
	return r
}

// Includes bulletins whose message that match this regular expression.
func (r FlowAPIGetBulletinBoardRequest) Message(message string) FlowAPIGetBulletinBoardRequest {
	r.message = &message
	return r
}

// Includes bulletins originating from this sources whose id match this regular expression.
func (r FlowAPIGetBulletinBoardRequest) SourceId(sourceId string) FlowAPIGetBulletinBoardRequest {
	r.sourceId = &sourceId
	return r
}

// Includes bulletins originating from this sources whose group id match this regular expression.
func (r FlowAPIGetBulletinBoardRequest) GroupId(groupId string) FlowAPIGetBulletinBoardRequest {
	r.groupId = &groupId
	return r
}

// The number of bulletins to limit the response to.
func (r FlowAPIGetBulletinBoardRequest) Limit(limit string) FlowAPIGetBulletinBoardRequest {
	r.limit = &limit
	return r
}

func (r FlowAPIGetBulletinBoardRequest) Execute() (*BulletinBoardEntity, *http.Response, error) {
	return r.ApiService.GetBulletinBoardExecute(r)
}

/*
GetBulletinBoard Gets current bulletins

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FlowAPIGetBulletinBoardRequest
*/
func (a *FlowAPIService) GetBulletinBoard(ctx context.Context) FlowAPIGetBulletinBoardRequest {
	return FlowAPIGetBulletinBoardRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BulletinBoardEntity
func (a *FlowAPIService) GetBulletinBoardExecute(r FlowAPIGetBulletinBoardRequest) (*BulletinBoardEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BulletinBoardEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowAPIService.GetBulletinBoard")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/bulletin-board"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "")
	}
	if r.sourceName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sourceName", r.sourceName, "")
	}
	if r.message != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "message", r.message, "")
	}
	if r.sourceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sourceId", r.sourceId, "")
	}
	if r.groupId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "groupId", r.groupId, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowAPIGetBulletinsRequest struct {
	ctx context.Context
	ApiService *FlowAPIService
}

func (r FlowAPIGetBulletinsRequest) Execute() (*ControllerBulletinsEntity, *http.Response, error) {
	return r.ApiService.GetBulletinsExecute(r)
}

/*
GetBulletins Retrieves Controller level bulletins

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FlowAPIGetBulletinsRequest
*/
func (a *FlowAPIService) GetBulletins(ctx context.Context) FlowAPIGetBulletinsRequest {
	return FlowAPIGetBulletinsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ControllerBulletinsEntity
func (a *FlowAPIService) GetBulletinsExecute(r FlowAPIGetBulletinsRequest) (*ControllerBulletinsEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ControllerBulletinsEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowAPIService.GetBulletins")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/controller/bulletins"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowAPIGetClusterSummaryRequest struct {
	ctx context.Context
	ApiService *FlowAPIService
}

func (r FlowAPIGetClusterSummaryRequest) Execute() (*ClusteSummaryEntity, *http.Response, error) {
	return r.ApiService.GetClusterSummaryExecute(r)
}

/*
GetClusterSummary The cluster summary for this NiFi

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FlowAPIGetClusterSummaryRequest
*/
func (a *FlowAPIService) GetClusterSummary(ctx context.Context) FlowAPIGetClusterSummaryRequest {
	return FlowAPIGetClusterSummaryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ClusteSummaryEntity
func (a *FlowAPIService) GetClusterSummaryExecute(r FlowAPIGetClusterSummaryRequest) (*ClusteSummaryEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ClusteSummaryEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowAPIService.GetClusterSummary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/cluster/summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowAPIGetComponentHistoryRequest struct {
	ctx context.Context
	ApiService *FlowAPIService
	componentId string
}

func (r FlowAPIGetComponentHistoryRequest) Execute() (*ComponentHistoryEntity, *http.Response, error) {
	return r.ApiService.GetComponentHistoryExecute(r)
}

/*
GetComponentHistory Gets configuration history for a component

Note: This endpoint is subject to change as NiFi and it's REST API evolve.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param componentId The component id.
 @return FlowAPIGetComponentHistoryRequest
*/
func (a *FlowAPIService) GetComponentHistory(ctx context.Context, componentId string) FlowAPIGetComponentHistoryRequest {
	return FlowAPIGetComponentHistoryRequest{
		ApiService: a,
		ctx: ctx,
		componentId: componentId,
	}
}

// Execute executes the request
//  @return ComponentHistoryEntity
func (a *FlowAPIService) GetComponentHistoryExecute(r FlowAPIGetComponentHistoryRequest) (*ComponentHistoryEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComponentHistoryEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowAPIService.GetComponentHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/history/components/{componentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"componentId"+"}", url.PathEscape(parameterValueToString(r.componentId, "componentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowAPIGetConnectionStatisticsRequest struct {
	ctx context.Context
	ApiService *FlowAPIService
	id string
	nodewise *bool
	clusterNodeId *string
}

// Whether or not to include the breakdown per node. Optional, defaults to false
func (r FlowAPIGetConnectionStatisticsRequest) Nodewise(nodewise bool) FlowAPIGetConnectionStatisticsRequest {
	r.nodewise = &nodewise
	return r
}

// The id of the node where to get the statistics.
func (r FlowAPIGetConnectionStatisticsRequest) ClusterNodeId(clusterNodeId string) FlowAPIGetConnectionStatisticsRequest {
	r.clusterNodeId = &clusterNodeId
	return r
}

func (r FlowAPIGetConnectionStatisticsRequest) Execute() (*ConnectionStatisticsEntity, *http.Response, error) {
	return r.ApiService.GetConnectionStatisticsExecute(r)
}

/*
GetConnectionStatistics Gets statistics for a connection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The connection id.
 @return FlowAPIGetConnectionStatisticsRequest
*/
func (a *FlowAPIService) GetConnectionStatistics(ctx context.Context, id string) FlowAPIGetConnectionStatisticsRequest {
	return FlowAPIGetConnectionStatisticsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConnectionStatisticsEntity
func (a *FlowAPIService) GetConnectionStatisticsExecute(r FlowAPIGetConnectionStatisticsRequest) (*ConnectionStatisticsEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConnectionStatisticsEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowAPIService.GetConnectionStatistics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/connections/{id}/statistics"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.nodewise != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nodewise", r.nodewise, "")
	}
	if r.clusterNodeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clusterNodeId", r.clusterNodeId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowAPIGetConnectionStatusRequest struct {
	ctx context.Context
	ApiService *FlowAPIService
	id string
	nodewise *bool
	clusterNodeId *string
}

// Whether or not to include the breakdown per node. Optional, defaults to false
func (r FlowAPIGetConnectionStatusRequest) Nodewise(nodewise bool) FlowAPIGetConnectionStatusRequest {
	r.nodewise = &nodewise
	return r
}

// The id of the node where to get the status.
func (r FlowAPIGetConnectionStatusRequest) ClusterNodeId(clusterNodeId string) FlowAPIGetConnectionStatusRequest {
	r.clusterNodeId = &clusterNodeId
	return r
}

func (r FlowAPIGetConnectionStatusRequest) Execute() (*ConnectionStatusEntity, *http.Response, error) {
	return r.ApiService.GetConnectionStatusExecute(r)
}

/*
GetConnectionStatus Gets status for a connection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The connection id.
 @return FlowAPIGetConnectionStatusRequest
*/
func (a *FlowAPIService) GetConnectionStatus(ctx context.Context, id string) FlowAPIGetConnectionStatusRequest {
	return FlowAPIGetConnectionStatusRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ConnectionStatusEntity
func (a *FlowAPIService) GetConnectionStatusExecute(r FlowAPIGetConnectionStatusRequest) (*ConnectionStatusEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConnectionStatusEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowAPIService.GetConnectionStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/connections/{id}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.nodewise != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nodewise", r.nodewise, "")
	}
	if r.clusterNodeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clusterNodeId", r.clusterNodeId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowAPIGetConnectionStatusHistoryRequest struct {
	ctx context.Context
	ApiService *FlowAPIService
	id string
}

func (r FlowAPIGetConnectionStatusHistoryRequest) Execute() (*StatusHistoryEntity, *http.Response, error) {
	return r.ApiService.GetConnectionStatusHistoryExecute(r)
}

/*
GetConnectionStatusHistory Gets the status history for a connection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The connection id.
 @return FlowAPIGetConnectionStatusHistoryRequest
*/
func (a *FlowAPIService) GetConnectionStatusHistory(ctx context.Context, id string) FlowAPIGetConnectionStatusHistoryRequest {
	return FlowAPIGetConnectionStatusHistoryRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return StatusHistoryEntity
func (a *FlowAPIService) GetConnectionStatusHistoryExecute(r FlowAPIGetConnectionStatusHistoryRequest) (*StatusHistoryEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StatusHistoryEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowAPIService.GetConnectionStatusHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/connections/{id}/status/history"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowAPIGetControllerServiceTypesRequest struct {
	ctx context.Context
	ApiService *FlowAPIService
	serviceType *string
	serviceBundleGroup *string
	serviceBundleArtifact *string
	serviceBundleVersion *string
	bundleGroupFilter *string
	bundleArtifactFilter *string
	typeFilter *string
}

// If specified, will only return controller services that are compatible with this type of service.
func (r FlowAPIGetControllerServiceTypesRequest) ServiceType(serviceType string) FlowAPIGetControllerServiceTypesRequest {
	r.serviceType = &serviceType
	return r
}

// If serviceType specified, is the bundle group of the serviceType.
func (r FlowAPIGetControllerServiceTypesRequest) ServiceBundleGroup(serviceBundleGroup string) FlowAPIGetControllerServiceTypesRequest {
	r.serviceBundleGroup = &serviceBundleGroup
	return r
}

// If serviceType specified, is the bundle artifact of the serviceType.
func (r FlowAPIGetControllerServiceTypesRequest) ServiceBundleArtifact(serviceBundleArtifact string) FlowAPIGetControllerServiceTypesRequest {
	r.serviceBundleArtifact = &serviceBundleArtifact
	return r
}

// If serviceType specified, is the bundle version of the serviceType.
func (r FlowAPIGetControllerServiceTypesRequest) ServiceBundleVersion(serviceBundleVersion string) FlowAPIGetControllerServiceTypesRequest {
	r.serviceBundleVersion = &serviceBundleVersion
	return r
}

// If specified, will only return types that are a member of this bundle group.
func (r FlowAPIGetControllerServiceTypesRequest) BundleGroupFilter(bundleGroupFilter string) FlowAPIGetControllerServiceTypesRequest {
	r.bundleGroupFilter = &bundleGroupFilter
	return r
}

// If specified, will only return types that are a member of this bundle artifact.
func (r FlowAPIGetControllerServiceTypesRequest) BundleArtifactFilter(bundleArtifactFilter string) FlowAPIGetControllerServiceTypesRequest {
	r.bundleArtifactFilter = &bundleArtifactFilter
	return r
}

// If specified, will only return types whose fully qualified classname matches.
func (r FlowAPIGetControllerServiceTypesRequest) TypeFilter(typeFilter string) FlowAPIGetControllerServiceTypesRequest {
	r.typeFilter = &typeFilter
	return r
}

func (r FlowAPIGetControllerServiceTypesRequest) Execute() (*ControllerServiceTypesEntity, *http.Response, error) {
	return r.ApiService.GetControllerServiceTypesExecute(r)
}

/*
GetControllerServiceTypes Retrieves the types of controller services that this NiFi supports

Note: This endpoint is subject to change as NiFi and it's REST API evolve.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FlowAPIGetControllerServiceTypesRequest
*/
func (a *FlowAPIService) GetControllerServiceTypes(ctx context.Context) FlowAPIGetControllerServiceTypesRequest {
	return FlowAPIGetControllerServiceTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ControllerServiceTypesEntity
func (a *FlowAPIService) GetControllerServiceTypesExecute(r FlowAPIGetControllerServiceTypesRequest) (*ControllerServiceTypesEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ControllerServiceTypesEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowAPIService.GetControllerServiceTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/controller-service-types"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.serviceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "serviceType", r.serviceType, "")
	}
	if r.serviceBundleGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "serviceBundleGroup", r.serviceBundleGroup, "")
	}
	if r.serviceBundleArtifact != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "serviceBundleArtifact", r.serviceBundleArtifact, "")
	}
	if r.serviceBundleVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "serviceBundleVersion", r.serviceBundleVersion, "")
	}
	if r.bundleGroupFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bundleGroupFilter", r.bundleGroupFilter, "")
	}
	if r.bundleArtifactFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bundleArtifactFilter", r.bundleArtifactFilter, "")
	}
	if r.typeFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "typeFilter", r.typeFilter, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowAPIGetControllerServicesFromControllerRequest struct {
	ctx context.Context
	ApiService *FlowAPIService
	uiOnly *bool
}

func (r FlowAPIGetControllerServicesFromControllerRequest) UiOnly(uiOnly bool) FlowAPIGetControllerServicesFromControllerRequest {
	r.uiOnly = &uiOnly
	return r
}

func (r FlowAPIGetControllerServicesFromControllerRequest) Execute() (*ControllerServicesEntity, *http.Response, error) {
	return r.ApiService.GetControllerServicesFromControllerExecute(r)
}

/*
GetControllerServicesFromController Gets controller services for reporting tasks

If the uiOnly query parameter is provided with a value of true, the returned entity may only contain fields that are necessary for rendering the NiFi User Interface. As such, the selected fields may change at any time, even during incremental releases, without warning. As a result, this parameter should not be provided by any client other than the UI.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FlowAPIGetControllerServicesFromControllerRequest
*/
func (a *FlowAPIService) GetControllerServicesFromController(ctx context.Context) FlowAPIGetControllerServicesFromControllerRequest {
	return FlowAPIGetControllerServicesFromControllerRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ControllerServicesEntity
func (a *FlowAPIService) GetControllerServicesFromControllerExecute(r FlowAPIGetControllerServicesFromControllerRequest) (*ControllerServicesEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ControllerServicesEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowAPIService.GetControllerServicesFromController")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/controller/controller-services"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.uiOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uiOnly", r.uiOnly, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowAPIGetControllerServicesFromGroupRequest struct {
	ctx context.Context
	ApiService *FlowAPIService
	id string
	includeAncestorGroups *bool
	includeDescendantGroups *bool
	uiOnly *bool
}

// Whether or not to include parent/ancestory process groups
func (r FlowAPIGetControllerServicesFromGroupRequest) IncludeAncestorGroups(includeAncestorGroups bool) FlowAPIGetControllerServicesFromGroupRequest {
	r.includeAncestorGroups = &includeAncestorGroups
	return r
}

// Whether or not to include descendant process groups
func (r FlowAPIGetControllerServicesFromGroupRequest) IncludeDescendantGroups(includeDescendantGroups bool) FlowAPIGetControllerServicesFromGroupRequest {
	r.includeDescendantGroups = &includeDescendantGroups
	return r
}

func (r FlowAPIGetControllerServicesFromGroupRequest) UiOnly(uiOnly bool) FlowAPIGetControllerServicesFromGroupRequest {
	r.uiOnly = &uiOnly
	return r
}

func (r FlowAPIGetControllerServicesFromGroupRequest) Execute() (*ControllerServicesEntity, *http.Response, error) {
	return r.ApiService.GetControllerServicesFromGroupExecute(r)
}

/*
GetControllerServicesFromGroup Gets all controller services

If the uiOnly query parameter is provided with a value of true, the returned entity may only contain fields that are necessary for rendering the NiFi User Interface. As such, the selected fields may change at any time, even during incremental releases, without warning. As a result, this parameter should not be provided by any client other than the UI.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The process group id.
 @return FlowAPIGetControllerServicesFromGroupRequest
*/
func (a *FlowAPIService) GetControllerServicesFromGroup(ctx context.Context, id string) FlowAPIGetControllerServicesFromGroupRequest {
	return FlowAPIGetControllerServicesFromGroupRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ControllerServicesEntity
func (a *FlowAPIService) GetControllerServicesFromGroupExecute(r FlowAPIGetControllerServicesFromGroupRequest) (*ControllerServicesEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ControllerServicesEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowAPIService.GetControllerServicesFromGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/process-groups/{id}/controller-services"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeAncestorGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeAncestorGroups", r.includeAncestorGroups, "")
	}
	if r.includeDescendantGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeDescendantGroups", r.includeDescendantGroups, "")
	}
	if r.uiOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uiOnly", r.uiOnly, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowAPIGetControllerStatusRequest struct {
	ctx context.Context
	ApiService *FlowAPIService
}

func (r FlowAPIGetControllerStatusRequest) Execute() (*ControllerStatusEntity, *http.Response, error) {
	return r.ApiService.GetControllerStatusExecute(r)
}

/*
GetControllerStatus Gets the current status of this NiFi

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FlowAPIGetControllerStatusRequest
*/
func (a *FlowAPIService) GetControllerStatus(ctx context.Context) FlowAPIGetControllerStatusRequest {
	return FlowAPIGetControllerStatusRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ControllerStatusEntity
func (a *FlowAPIService) GetControllerStatusExecute(r FlowAPIGetControllerStatusRequest) (*ControllerStatusEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ControllerStatusEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowAPIService.GetControllerStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowAPIGetCurrentUserRequest struct {
	ctx context.Context
	ApiService *FlowAPIService
}

func (r FlowAPIGetCurrentUserRequest) Execute() (*CurrentUserEntity, *http.Response, error) {
	return r.ApiService.GetCurrentUserExecute(r)
}

/*
GetCurrentUser Retrieves the user identity of the user making the request

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FlowAPIGetCurrentUserRequest
*/
func (a *FlowAPIService) GetCurrentUser(ctx context.Context) FlowAPIGetCurrentUserRequest {
	return FlowAPIGetCurrentUserRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CurrentUserEntity
func (a *FlowAPIService) GetCurrentUserExecute(r FlowAPIGetCurrentUserRequest) (*CurrentUserEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CurrentUserEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowAPIService.GetCurrentUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/current-user"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowAPIGetDetailsRequest struct {
	ctx context.Context
	ApiService *FlowAPIService
	registryId string
	bucketId string
	flowId string
}

func (r FlowAPIGetDetailsRequest) Execute() (*VersionedFlowEntity, *http.Response, error) {
	return r.ApiService.GetDetailsExecute(r)
}

/*
GetDetails Gets the details of a flow from the specified registry and bucket for the specified flow for the current user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param registryId The registry client id.
 @param bucketId The bucket id.
 @param flowId The flow id.
 @return FlowAPIGetDetailsRequest
*/
func (a *FlowAPIService) GetDetails(ctx context.Context, registryId string, bucketId string, flowId string) FlowAPIGetDetailsRequest {
	return FlowAPIGetDetailsRequest{
		ApiService: a,
		ctx: ctx,
		registryId: registryId,
		bucketId: bucketId,
		flowId: flowId,
	}
}

// Execute executes the request
//  @return VersionedFlowEntity
func (a *FlowAPIService) GetDetailsExecute(r FlowAPIGetDetailsRequest) (*VersionedFlowEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VersionedFlowEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowAPIService.GetDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/registries/{registry-id}/buckets/{bucket-id}/flows/{flow-id}/details"
	localVarPath = strings.Replace(localVarPath, "{"+"registry-id"+"}", url.PathEscape(parameterValueToString(r.registryId, "registryId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"bucket-id"+"}", url.PathEscape(parameterValueToString(r.bucketId, "bucketId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"flow-id"+"}", url.PathEscape(parameterValueToString(r.flowId, "flowId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowAPIGetFlowRequest struct {
	ctx context.Context
	ApiService *FlowAPIService
	id string
	uiOnly *bool
}

func (r FlowAPIGetFlowRequest) UiOnly(uiOnly bool) FlowAPIGetFlowRequest {
	r.uiOnly = &uiOnly
	return r
}

func (r FlowAPIGetFlowRequest) Execute() (*ProcessGroupFlowEntity, *http.Response, error) {
	return r.ApiService.GetFlowExecute(r)
}

/*
GetFlow Gets a process group

If the uiOnly query parameter is provided with a value of true, the returned entity may only contain fields that are necessary for rendering the NiFi User Interface. As such, the selected fields may change at any time, even during incremental releases, without warning. As a result, this parameter should not be provided by any client other than the UI.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The process group id.
 @return FlowAPIGetFlowRequest
*/
func (a *FlowAPIService) GetFlow(ctx context.Context, id string) FlowAPIGetFlowRequest {
	return FlowAPIGetFlowRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ProcessGroupFlowEntity
func (a *FlowAPIService) GetFlowExecute(r FlowAPIGetFlowRequest) (*ProcessGroupFlowEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProcessGroupFlowEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowAPIService.GetFlow")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/process-groups/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.uiOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uiOnly", r.uiOnly, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowAPIGetFlowConfigRequest struct {
	ctx context.Context
	ApiService *FlowAPIService
}

func (r FlowAPIGetFlowConfigRequest) Execute() (*FlowConfigurationEntity, *http.Response, error) {
	return r.ApiService.GetFlowConfigExecute(r)
}

/*
GetFlowConfig Retrieves the configuration for this NiFi flow

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FlowAPIGetFlowConfigRequest
*/
func (a *FlowAPIService) GetFlowConfig(ctx context.Context) FlowAPIGetFlowConfigRequest {
	return FlowAPIGetFlowConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FlowConfigurationEntity
func (a *FlowAPIService) GetFlowConfigExecute(r FlowAPIGetFlowConfigRequest) (*FlowConfigurationEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FlowConfigurationEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowAPIService.GetFlowConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowAPIGetFlowMetricsRequest struct {
	ctx context.Context
	ApiService *FlowAPIService
	producer string
	includedRegistries *[]string
	sampleName *string
	sampleLabelValue *string
	rootFieldName *string
}

// Set of included metrics registries
func (r FlowAPIGetFlowMetricsRequest) IncludedRegistries(includedRegistries []string) FlowAPIGetFlowMetricsRequest {
	r.includedRegistries = &includedRegistries
	return r
}

// Regular Expression Pattern to be applied against the sample name field
func (r FlowAPIGetFlowMetricsRequest) SampleName(sampleName string) FlowAPIGetFlowMetricsRequest {
	r.sampleName = &sampleName
	return r
}

// Regular Expression Pattern to be applied against the sample label value field
func (r FlowAPIGetFlowMetricsRequest) SampleLabelValue(sampleLabelValue string) FlowAPIGetFlowMetricsRequest {
	r.sampleLabelValue = &sampleLabelValue
	return r
}

// Name of the first field of JSON object. Applicable for JSON producer only.
func (r FlowAPIGetFlowMetricsRequest) RootFieldName(rootFieldName string) FlowAPIGetFlowMetricsRequest {
	r.rootFieldName = &rootFieldName
	return r
}

func (r FlowAPIGetFlowMetricsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetFlowMetricsExecute(r)
}

/*
GetFlowMetrics Gets all metrics for the flow from a particular node

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param producer The producer for flow file metrics. Each producer may have its own output format.
 @return FlowAPIGetFlowMetricsRequest
*/
func (a *FlowAPIService) GetFlowMetrics(ctx context.Context, producer string) FlowAPIGetFlowMetricsRequest {
	return FlowAPIGetFlowMetricsRequest{
		ApiService: a,
		ctx: ctx,
		producer: producer,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *FlowAPIService) GetFlowMetricsExecute(r FlowAPIGetFlowMetricsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowAPIService.GetFlowMetrics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/metrics/{producer}"
	localVarPath = strings.Replace(localVarPath, "{"+"producer"+"}", url.PathEscape(parameterValueToString(r.producer, "producer")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includedRegistries != nil {
		t := *r.includedRegistries
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "includedRegistries", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "includedRegistries", t, "multi")
		}
	}
	if r.sampleName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sampleName", r.sampleName, "")
	}
	if r.sampleLabelValue != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sampleLabelValue", r.sampleLabelValue, "")
	}
	if r.rootFieldName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rootFieldName", r.rootFieldName, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowAPIGetFlowsRequest struct {
	ctx context.Context
	ApiService *FlowAPIService
	registryId string
	bucketId string
}

func (r FlowAPIGetFlowsRequest) Execute() (*VersionedFlowsEntity, *http.Response, error) {
	return r.ApiService.GetFlowsExecute(r)
}

/*
GetFlows Gets the flows from the specified registry and bucket for the current user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param registryId The registry client id.
 @param bucketId The bucket id.
 @return FlowAPIGetFlowsRequest
*/
func (a *FlowAPIService) GetFlows(ctx context.Context, registryId string, bucketId string) FlowAPIGetFlowsRequest {
	return FlowAPIGetFlowsRequest{
		ApiService: a,
		ctx: ctx,
		registryId: registryId,
		bucketId: bucketId,
	}
}

// Execute executes the request
//  @return VersionedFlowsEntity
func (a *FlowAPIService) GetFlowsExecute(r FlowAPIGetFlowsRequest) (*VersionedFlowsEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VersionedFlowsEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowAPIService.GetFlows")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/registries/{registry-id}/buckets/{bucket-id}/flows"
	localVarPath = strings.Replace(localVarPath, "{"+"registry-id"+"}", url.PathEscape(parameterValueToString(r.registryId, "registryId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"bucket-id"+"}", url.PathEscape(parameterValueToString(r.bucketId, "bucketId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowAPIGetInputPortStatusRequest struct {
	ctx context.Context
	ApiService *FlowAPIService
	id string
	nodewise *bool
	clusterNodeId *string
}

// Whether or not to include the breakdown per node. Optional, defaults to false
func (r FlowAPIGetInputPortStatusRequest) Nodewise(nodewise bool) FlowAPIGetInputPortStatusRequest {
	r.nodewise = &nodewise
	return r
}

// The id of the node where to get the status.
func (r FlowAPIGetInputPortStatusRequest) ClusterNodeId(clusterNodeId string) FlowAPIGetInputPortStatusRequest {
	r.clusterNodeId = &clusterNodeId
	return r
}

func (r FlowAPIGetInputPortStatusRequest) Execute() (*PortStatusEntity, *http.Response, error) {
	return r.ApiService.GetInputPortStatusExecute(r)
}

/*
GetInputPortStatus Gets status for an input port

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The input port id.
 @return FlowAPIGetInputPortStatusRequest
*/
func (a *FlowAPIService) GetInputPortStatus(ctx context.Context, id string) FlowAPIGetInputPortStatusRequest {
	return FlowAPIGetInputPortStatusRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PortStatusEntity
func (a *FlowAPIService) GetInputPortStatusExecute(r FlowAPIGetInputPortStatusRequest) (*PortStatusEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PortStatusEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowAPIService.GetInputPortStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/input-ports/{id}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.nodewise != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nodewise", r.nodewise, "")
	}
	if r.clusterNodeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clusterNodeId", r.clusterNodeId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowAPIGetOutputPortStatusRequest struct {
	ctx context.Context
	ApiService *FlowAPIService
	id string
	nodewise *bool
	clusterNodeId *string
}

// Whether or not to include the breakdown per node. Optional, defaults to false
func (r FlowAPIGetOutputPortStatusRequest) Nodewise(nodewise bool) FlowAPIGetOutputPortStatusRequest {
	r.nodewise = &nodewise
	return r
}

// The id of the node where to get the status.
func (r FlowAPIGetOutputPortStatusRequest) ClusterNodeId(clusterNodeId string) FlowAPIGetOutputPortStatusRequest {
	r.clusterNodeId = &clusterNodeId
	return r
}

func (r FlowAPIGetOutputPortStatusRequest) Execute() (*PortStatusEntity, *http.Response, error) {
	return r.ApiService.GetOutputPortStatusExecute(r)
}

/*
GetOutputPortStatus Gets status for an output port

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The output port id.
 @return FlowAPIGetOutputPortStatusRequest
*/
func (a *FlowAPIService) GetOutputPortStatus(ctx context.Context, id string) FlowAPIGetOutputPortStatusRequest {
	return FlowAPIGetOutputPortStatusRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PortStatusEntity
func (a *FlowAPIService) GetOutputPortStatusExecute(r FlowAPIGetOutputPortStatusRequest) (*PortStatusEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PortStatusEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowAPIService.GetOutputPortStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/output-ports/{id}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.nodewise != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nodewise", r.nodewise, "")
	}
	if r.clusterNodeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clusterNodeId", r.clusterNodeId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowAPIGetParameterContextsRequest struct {
	ctx context.Context
	ApiService *FlowAPIService
}

func (r FlowAPIGetParameterContextsRequest) Execute() (*ParameterContextsEntity, *http.Response, error) {
	return r.ApiService.GetParameterContextsExecute(r)
}

/*
GetParameterContexts Gets all Parameter Contexts

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FlowAPIGetParameterContextsRequest
*/
func (a *FlowAPIService) GetParameterContexts(ctx context.Context) FlowAPIGetParameterContextsRequest {
	return FlowAPIGetParameterContextsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ParameterContextsEntity
func (a *FlowAPIService) GetParameterContextsExecute(r FlowAPIGetParameterContextsRequest) (*ParameterContextsEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ParameterContextsEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowAPIService.GetParameterContexts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/parameter-contexts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowAPIGetParameterProviderTypesRequest struct {
	ctx context.Context
	ApiService *FlowAPIService
	bundleGroupFilter *string
	bundleArtifactFilter *string
	type_ *string
}

// If specified, will only return types that are a member of this bundle group.
func (r FlowAPIGetParameterProviderTypesRequest) BundleGroupFilter(bundleGroupFilter string) FlowAPIGetParameterProviderTypesRequest {
	r.bundleGroupFilter = &bundleGroupFilter
	return r
}

// If specified, will only return types that are a member of this bundle artifact.
func (r FlowAPIGetParameterProviderTypesRequest) BundleArtifactFilter(bundleArtifactFilter string) FlowAPIGetParameterProviderTypesRequest {
	r.bundleArtifactFilter = &bundleArtifactFilter
	return r
}

// If specified, will only return types whose fully qualified classname matches.
func (r FlowAPIGetParameterProviderTypesRequest) Type_(type_ string) FlowAPIGetParameterProviderTypesRequest {
	r.type_ = &type_
	return r
}

func (r FlowAPIGetParameterProviderTypesRequest) Execute() (*ParameterProviderTypesEntity, *http.Response, error) {
	return r.ApiService.GetParameterProviderTypesExecute(r)
}

/*
GetParameterProviderTypes Retrieves the types of parameter providers that this NiFi supports

Note: This endpoint is subject to change as NiFi and it's REST API evolve.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FlowAPIGetParameterProviderTypesRequest
*/
func (a *FlowAPIService) GetParameterProviderTypes(ctx context.Context) FlowAPIGetParameterProviderTypesRequest {
	return FlowAPIGetParameterProviderTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ParameterProviderTypesEntity
func (a *FlowAPIService) GetParameterProviderTypesExecute(r FlowAPIGetParameterProviderTypesRequest) (*ParameterProviderTypesEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ParameterProviderTypesEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowAPIService.GetParameterProviderTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/parameter-provider-types"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.bundleGroupFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bundleGroupFilter", r.bundleGroupFilter, "")
	}
	if r.bundleArtifactFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bundleArtifactFilter", r.bundleArtifactFilter, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowAPIGetParameterProvidersRequest struct {
	ctx context.Context
	ApiService *FlowAPIService
}

func (r FlowAPIGetParameterProvidersRequest) Execute() (*ParameterProvidersEntity, *http.Response, error) {
	return r.ApiService.GetParameterProvidersExecute(r)
}

/*
GetParameterProviders Gets all parameter providers

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FlowAPIGetParameterProvidersRequest
*/
func (a *FlowAPIService) GetParameterProviders(ctx context.Context) FlowAPIGetParameterProvidersRequest {
	return FlowAPIGetParameterProvidersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ParameterProvidersEntity
func (a *FlowAPIService) GetParameterProvidersExecute(r FlowAPIGetParameterProvidersRequest) (*ParameterProvidersEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ParameterProvidersEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowAPIService.GetParameterProviders")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/parameter-providers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowAPIGetPrioritizersRequest struct {
	ctx context.Context
	ApiService *FlowAPIService
}

func (r FlowAPIGetPrioritizersRequest) Execute() (*PrioritizerTypesEntity, *http.Response, error) {
	return r.ApiService.GetPrioritizersExecute(r)
}

/*
GetPrioritizers Retrieves the types of prioritizers that this NiFi supports

Note: This endpoint is subject to change as NiFi and it's REST API evolve.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FlowAPIGetPrioritizersRequest
*/
func (a *FlowAPIService) GetPrioritizers(ctx context.Context) FlowAPIGetPrioritizersRequest {
	return FlowAPIGetPrioritizersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PrioritizerTypesEntity
func (a *FlowAPIService) GetPrioritizersExecute(r FlowAPIGetPrioritizersRequest) (*PrioritizerTypesEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PrioritizerTypesEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowAPIService.GetPrioritizers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/prioritizers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowAPIGetProcessGroupStatusRequest struct {
	ctx context.Context
	ApiService *FlowAPIService
	id string
	recursive *bool
	nodewise *bool
	clusterNodeId *string
}

// Whether all descendant groups and the status of their content will be included. Optional, defaults to false
func (r FlowAPIGetProcessGroupStatusRequest) Recursive(recursive bool) FlowAPIGetProcessGroupStatusRequest {
	r.recursive = &recursive
	return r
}

// Whether or not to include the breakdown per node. Optional, defaults to false
func (r FlowAPIGetProcessGroupStatusRequest) Nodewise(nodewise bool) FlowAPIGetProcessGroupStatusRequest {
	r.nodewise = &nodewise
	return r
}

// The id of the node where to get the status.
func (r FlowAPIGetProcessGroupStatusRequest) ClusterNodeId(clusterNodeId string) FlowAPIGetProcessGroupStatusRequest {
	r.clusterNodeId = &clusterNodeId
	return r
}

func (r FlowAPIGetProcessGroupStatusRequest) Execute() (*ProcessGroupStatusEntity, *http.Response, error) {
	return r.ApiService.GetProcessGroupStatusExecute(r)
}

/*
GetProcessGroupStatus Gets the status for a process group

The status for a process group includes status for all descendent components. When invoked on the root group with recursive set to true, it will return the current status of every component in the flow.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The process group id.
 @return FlowAPIGetProcessGroupStatusRequest
*/
func (a *FlowAPIService) GetProcessGroupStatus(ctx context.Context, id string) FlowAPIGetProcessGroupStatusRequest {
	return FlowAPIGetProcessGroupStatusRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ProcessGroupStatusEntity
func (a *FlowAPIService) GetProcessGroupStatusExecute(r FlowAPIGetProcessGroupStatusRequest) (*ProcessGroupStatusEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProcessGroupStatusEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowAPIService.GetProcessGroupStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/process-groups/{id}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.recursive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recursive", r.recursive, "")
	}
	if r.nodewise != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nodewise", r.nodewise, "")
	}
	if r.clusterNodeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clusterNodeId", r.clusterNodeId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowAPIGetProcessGroupStatusHistoryRequest struct {
	ctx context.Context
	ApiService *FlowAPIService
	id string
}

func (r FlowAPIGetProcessGroupStatusHistoryRequest) Execute() (*StatusHistoryEntity, *http.Response, error) {
	return r.ApiService.GetProcessGroupStatusHistoryExecute(r)
}

/*
GetProcessGroupStatusHistory Gets status history for a remote process group

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The process group id.
 @return FlowAPIGetProcessGroupStatusHistoryRequest
*/
func (a *FlowAPIService) GetProcessGroupStatusHistory(ctx context.Context, id string) FlowAPIGetProcessGroupStatusHistoryRequest {
	return FlowAPIGetProcessGroupStatusHistoryRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return StatusHistoryEntity
func (a *FlowAPIService) GetProcessGroupStatusHistoryExecute(r FlowAPIGetProcessGroupStatusHistoryRequest) (*StatusHistoryEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StatusHistoryEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowAPIService.GetProcessGroupStatusHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/process-groups/{id}/status/history"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowAPIGetProcessorStatusRequest struct {
	ctx context.Context
	ApiService *FlowAPIService
	id string
	nodewise *bool
	clusterNodeId *string
}

// Whether or not to include the breakdown per node. Optional, defaults to false
func (r FlowAPIGetProcessorStatusRequest) Nodewise(nodewise bool) FlowAPIGetProcessorStatusRequest {
	r.nodewise = &nodewise
	return r
}

// The id of the node where to get the status.
func (r FlowAPIGetProcessorStatusRequest) ClusterNodeId(clusterNodeId string) FlowAPIGetProcessorStatusRequest {
	r.clusterNodeId = &clusterNodeId
	return r
}

func (r FlowAPIGetProcessorStatusRequest) Execute() (*ProcessorStatusEntity, *http.Response, error) {
	return r.ApiService.GetProcessorStatusExecute(r)
}

/*
GetProcessorStatus Gets status for a processor

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The processor id.
 @return FlowAPIGetProcessorStatusRequest
*/
func (a *FlowAPIService) GetProcessorStatus(ctx context.Context, id string) FlowAPIGetProcessorStatusRequest {
	return FlowAPIGetProcessorStatusRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ProcessorStatusEntity
func (a *FlowAPIService) GetProcessorStatusExecute(r FlowAPIGetProcessorStatusRequest) (*ProcessorStatusEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProcessorStatusEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowAPIService.GetProcessorStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/processors/{id}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.nodewise != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nodewise", r.nodewise, "")
	}
	if r.clusterNodeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clusterNodeId", r.clusterNodeId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowAPIGetProcessorStatusHistoryRequest struct {
	ctx context.Context
	ApiService *FlowAPIService
	id string
}

func (r FlowAPIGetProcessorStatusHistoryRequest) Execute() (*StatusHistoryEntity, *http.Response, error) {
	return r.ApiService.GetProcessorStatusHistoryExecute(r)
}

/*
GetProcessorStatusHistory Gets status history for a processor

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The processor id.
 @return FlowAPIGetProcessorStatusHistoryRequest
*/
func (a *FlowAPIService) GetProcessorStatusHistory(ctx context.Context, id string) FlowAPIGetProcessorStatusHistoryRequest {
	return FlowAPIGetProcessorStatusHistoryRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return StatusHistoryEntity
func (a *FlowAPIService) GetProcessorStatusHistoryExecute(r FlowAPIGetProcessorStatusHistoryRequest) (*StatusHistoryEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StatusHistoryEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowAPIService.GetProcessorStatusHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/processors/{id}/status/history"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowAPIGetProcessorTypesRequest struct {
	ctx context.Context
	ApiService *FlowAPIService
	bundleGroupFilter *string
	bundleArtifactFilter *string
	type_ *string
}

// If specified, will only return types that are a member of this bundle group.
func (r FlowAPIGetProcessorTypesRequest) BundleGroupFilter(bundleGroupFilter string) FlowAPIGetProcessorTypesRequest {
	r.bundleGroupFilter = &bundleGroupFilter
	return r
}

// If specified, will only return types that are a member of this bundle artifact.
func (r FlowAPIGetProcessorTypesRequest) BundleArtifactFilter(bundleArtifactFilter string) FlowAPIGetProcessorTypesRequest {
	r.bundleArtifactFilter = &bundleArtifactFilter
	return r
}

// If specified, will only return types whose fully qualified classname matches.
func (r FlowAPIGetProcessorTypesRequest) Type_(type_ string) FlowAPIGetProcessorTypesRequest {
	r.type_ = &type_
	return r
}

func (r FlowAPIGetProcessorTypesRequest) Execute() (*ProcessorTypesEntity, *http.Response, error) {
	return r.ApiService.GetProcessorTypesExecute(r)
}

/*
GetProcessorTypes Retrieves the types of processors that this NiFi supports

Note: This endpoint is subject to change as NiFi and it's REST API evolve.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FlowAPIGetProcessorTypesRequest
*/
func (a *FlowAPIService) GetProcessorTypes(ctx context.Context) FlowAPIGetProcessorTypesRequest {
	return FlowAPIGetProcessorTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ProcessorTypesEntity
func (a *FlowAPIService) GetProcessorTypesExecute(r FlowAPIGetProcessorTypesRequest) (*ProcessorTypesEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProcessorTypesEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowAPIService.GetProcessorTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/processor-types"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.bundleGroupFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bundleGroupFilter", r.bundleGroupFilter, "")
	}
	if r.bundleArtifactFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bundleArtifactFilter", r.bundleArtifactFilter, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowAPIGetRegistryClientsRequest struct {
	ctx context.Context
	ApiService *FlowAPIService
}

func (r FlowAPIGetRegistryClientsRequest) Execute() (*FlowRegistryClientsEntity, *http.Response, error) {
	return r.ApiService.GetRegistryClientsExecute(r)
}

/*
GetRegistryClients Gets the listing of available flow registry clients

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FlowAPIGetRegistryClientsRequest
*/
func (a *FlowAPIService) GetRegistryClients(ctx context.Context) FlowAPIGetRegistryClientsRequest {
	return FlowAPIGetRegistryClientsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FlowRegistryClientsEntity
func (a *FlowAPIService) GetRegistryClientsExecute(r FlowAPIGetRegistryClientsRequest) (*FlowRegistryClientsEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FlowRegistryClientsEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowAPIService.GetRegistryClients")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/registries"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowAPIGetRemoteProcessGroupStatusRequest struct {
	ctx context.Context
	ApiService *FlowAPIService
	id string
	nodewise *bool
	clusterNodeId *string
}

// Whether or not to include the breakdown per node. Optional, defaults to false
func (r FlowAPIGetRemoteProcessGroupStatusRequest) Nodewise(nodewise bool) FlowAPIGetRemoteProcessGroupStatusRequest {
	r.nodewise = &nodewise
	return r
}

// The id of the node where to get the status.
func (r FlowAPIGetRemoteProcessGroupStatusRequest) ClusterNodeId(clusterNodeId string) FlowAPIGetRemoteProcessGroupStatusRequest {
	r.clusterNodeId = &clusterNodeId
	return r
}

func (r FlowAPIGetRemoteProcessGroupStatusRequest) Execute() (*RemoteProcessGroupStatusEntity, *http.Response, error) {
	return r.ApiService.GetRemoteProcessGroupStatusExecute(r)
}

/*
GetRemoteProcessGroupStatus Gets status for a remote process group

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The remote process group id.
 @return FlowAPIGetRemoteProcessGroupStatusRequest
*/
func (a *FlowAPIService) GetRemoteProcessGroupStatus(ctx context.Context, id string) FlowAPIGetRemoteProcessGroupStatusRequest {
	return FlowAPIGetRemoteProcessGroupStatusRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RemoteProcessGroupStatusEntity
func (a *FlowAPIService) GetRemoteProcessGroupStatusExecute(r FlowAPIGetRemoteProcessGroupStatusRequest) (*RemoteProcessGroupStatusEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RemoteProcessGroupStatusEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowAPIService.GetRemoteProcessGroupStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/remote-process-groups/{id}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.nodewise != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nodewise", r.nodewise, "")
	}
	if r.clusterNodeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clusterNodeId", r.clusterNodeId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowAPIGetRemoteProcessGroupStatusHistoryRequest struct {
	ctx context.Context
	ApiService *FlowAPIService
	id string
}

func (r FlowAPIGetRemoteProcessGroupStatusHistoryRequest) Execute() (*StatusHistoryEntity, *http.Response, error) {
	return r.ApiService.GetRemoteProcessGroupStatusHistoryExecute(r)
}

/*
GetRemoteProcessGroupStatusHistory Gets the status history

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The remote process group id.
 @return FlowAPIGetRemoteProcessGroupStatusHistoryRequest
*/
func (a *FlowAPIService) GetRemoteProcessGroupStatusHistory(ctx context.Context, id string) FlowAPIGetRemoteProcessGroupStatusHistoryRequest {
	return FlowAPIGetRemoteProcessGroupStatusHistoryRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return StatusHistoryEntity
func (a *FlowAPIService) GetRemoteProcessGroupStatusHistoryExecute(r FlowAPIGetRemoteProcessGroupStatusHistoryRequest) (*StatusHistoryEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StatusHistoryEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowAPIService.GetRemoteProcessGroupStatusHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/remote-process-groups/{id}/status/history"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowAPIGetReportingTaskTypesRequest struct {
	ctx context.Context
	ApiService *FlowAPIService
	bundleGroupFilter *string
	bundleArtifactFilter *string
	type_ *string
}

// If specified, will only return types that are a member of this bundle group.
func (r FlowAPIGetReportingTaskTypesRequest) BundleGroupFilter(bundleGroupFilter string) FlowAPIGetReportingTaskTypesRequest {
	r.bundleGroupFilter = &bundleGroupFilter
	return r
}

// If specified, will only return types that are a member of this bundle artifact.
func (r FlowAPIGetReportingTaskTypesRequest) BundleArtifactFilter(bundleArtifactFilter string) FlowAPIGetReportingTaskTypesRequest {
	r.bundleArtifactFilter = &bundleArtifactFilter
	return r
}

// If specified, will only return types whose fully qualified classname matches.
func (r FlowAPIGetReportingTaskTypesRequest) Type_(type_ string) FlowAPIGetReportingTaskTypesRequest {
	r.type_ = &type_
	return r
}

func (r FlowAPIGetReportingTaskTypesRequest) Execute() (*ReportingTaskTypesEntity, *http.Response, error) {
	return r.ApiService.GetReportingTaskTypesExecute(r)
}

/*
GetReportingTaskTypes Retrieves the types of reporting tasks that this NiFi supports

Note: This endpoint is subject to change as NiFi and it's REST API evolve.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FlowAPIGetReportingTaskTypesRequest
*/
func (a *FlowAPIService) GetReportingTaskTypes(ctx context.Context) FlowAPIGetReportingTaskTypesRequest {
	return FlowAPIGetReportingTaskTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ReportingTaskTypesEntity
func (a *FlowAPIService) GetReportingTaskTypesExecute(r FlowAPIGetReportingTaskTypesRequest) (*ReportingTaskTypesEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReportingTaskTypesEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowAPIService.GetReportingTaskTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/reporting-task-types"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.bundleGroupFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bundleGroupFilter", r.bundleGroupFilter, "")
	}
	if r.bundleArtifactFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bundleArtifactFilter", r.bundleArtifactFilter, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowAPIGetReportingTasksRequest struct {
	ctx context.Context
	ApiService *FlowAPIService
}

func (r FlowAPIGetReportingTasksRequest) Execute() (*ReportingTasksEntity, *http.Response, error) {
	return r.ApiService.GetReportingTasksExecute(r)
}

/*
GetReportingTasks Gets all reporting tasks

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FlowAPIGetReportingTasksRequest
*/
func (a *FlowAPIService) GetReportingTasks(ctx context.Context) FlowAPIGetReportingTasksRequest {
	return FlowAPIGetReportingTasksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ReportingTasksEntity
func (a *FlowAPIService) GetReportingTasksExecute(r FlowAPIGetReportingTasksRequest) (*ReportingTasksEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReportingTasksEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowAPIService.GetReportingTasks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/reporting-tasks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowAPIGetRuntimeManifestRequest struct {
	ctx context.Context
	ApiService *FlowAPIService
}

func (r FlowAPIGetRuntimeManifestRequest) Execute() (*RuntimeManifestEntity, *http.Response, error) {
	return r.ApiService.GetRuntimeManifestExecute(r)
}

/*
GetRuntimeManifest Retrieves the runtime manifest for this NiFi instance.

Note: This endpoint is subject to change as NiFi and it's REST API evolve.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FlowAPIGetRuntimeManifestRequest
*/
func (a *FlowAPIService) GetRuntimeManifest(ctx context.Context) FlowAPIGetRuntimeManifestRequest {
	return FlowAPIGetRuntimeManifestRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RuntimeManifestEntity
func (a *FlowAPIService) GetRuntimeManifestExecute(r FlowAPIGetRuntimeManifestRequest) (*RuntimeManifestEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RuntimeManifestEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowAPIService.GetRuntimeManifest")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/runtime-manifest"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowAPIGetTemplatesRequest struct {
	ctx context.Context
	ApiService *FlowAPIService
}

func (r FlowAPIGetTemplatesRequest) Execute() (*TemplatesEntity, *http.Response, error) {
	return r.ApiService.GetTemplatesExecute(r)
}

/*
GetTemplates Gets all templates

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FlowAPIGetTemplatesRequest
*/
func (a *FlowAPIService) GetTemplates(ctx context.Context) FlowAPIGetTemplatesRequest {
	return FlowAPIGetTemplatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TemplatesEntity
func (a *FlowAPIService) GetTemplatesExecute(r FlowAPIGetTemplatesRequest) (*TemplatesEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TemplatesEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowAPIService.GetTemplates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/templates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowAPIGetVersionsRequest struct {
	ctx context.Context
	ApiService *FlowAPIService
	registryId string
	bucketId string
	flowId string
}

func (r FlowAPIGetVersionsRequest) Execute() (*VersionedFlowSnapshotMetadataSetEntity, *http.Response, error) {
	return r.ApiService.GetVersionsExecute(r)
}

/*
GetVersions Gets the flow versions from the specified registry and bucket for the specified flow for the current user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param registryId The registry client id.
 @param bucketId The bucket id.
 @param flowId The flow id.
 @return FlowAPIGetVersionsRequest
*/
func (a *FlowAPIService) GetVersions(ctx context.Context, registryId string, bucketId string, flowId string) FlowAPIGetVersionsRequest {
	return FlowAPIGetVersionsRequest{
		ApiService: a,
		ctx: ctx,
		registryId: registryId,
		bucketId: bucketId,
		flowId: flowId,
	}
}

// Execute executes the request
//  @return VersionedFlowSnapshotMetadataSetEntity
func (a *FlowAPIService) GetVersionsExecute(r FlowAPIGetVersionsRequest) (*VersionedFlowSnapshotMetadataSetEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VersionedFlowSnapshotMetadataSetEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowAPIService.GetVersions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/registries/{registry-id}/buckets/{bucket-id}/flows/{flow-id}/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"registry-id"+"}", url.PathEscape(parameterValueToString(r.registryId, "registryId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"bucket-id"+"}", url.PathEscape(parameterValueToString(r.bucketId, "bucketId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"flow-id"+"}", url.PathEscape(parameterValueToString(r.flowId, "flowId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowAPIQueryHistoryRequest struct {
	ctx context.Context
	ApiService *FlowAPIService
	offset *string
	count *string
	sortColumn *string
	sortOrder *string
	startDate *string
	endDate *string
	userIdentity *string
	sourceId *string
}

// The offset into the result set.
func (r FlowAPIQueryHistoryRequest) Offset(offset string) FlowAPIQueryHistoryRequest {
	r.offset = &offset
	return r
}

// The number of actions to return.
func (r FlowAPIQueryHistoryRequest) Count(count string) FlowAPIQueryHistoryRequest {
	r.count = &count
	return r
}

// The field to sort on.
func (r FlowAPIQueryHistoryRequest) SortColumn(sortColumn string) FlowAPIQueryHistoryRequest {
	r.sortColumn = &sortColumn
	return r
}

// The direction to sort.
func (r FlowAPIQueryHistoryRequest) SortOrder(sortOrder string) FlowAPIQueryHistoryRequest {
	r.sortOrder = &sortOrder
	return r
}

// Include actions after this date.
func (r FlowAPIQueryHistoryRequest) StartDate(startDate string) FlowAPIQueryHistoryRequest {
	r.startDate = &startDate
	return r
}

// Include actions before this date.
func (r FlowAPIQueryHistoryRequest) EndDate(endDate string) FlowAPIQueryHistoryRequest {
	r.endDate = &endDate
	return r
}

// Include actions performed by this user.
func (r FlowAPIQueryHistoryRequest) UserIdentity(userIdentity string) FlowAPIQueryHistoryRequest {
	r.userIdentity = &userIdentity
	return r
}

// Include actions on this component.
func (r FlowAPIQueryHistoryRequest) SourceId(sourceId string) FlowAPIQueryHistoryRequest {
	r.sourceId = &sourceId
	return r
}

func (r FlowAPIQueryHistoryRequest) Execute() (*HistoryEntity, *http.Response, error) {
	return r.ApiService.QueryHistoryExecute(r)
}

/*
QueryHistory Gets configuration history

Note: This endpoint is subject to change as NiFi and it's REST API evolve.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FlowAPIQueryHistoryRequest
*/
func (a *FlowAPIService) QueryHistory(ctx context.Context) FlowAPIQueryHistoryRequest {
	return FlowAPIQueryHistoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return HistoryEntity
func (a *FlowAPIService) QueryHistoryExecute(r FlowAPIQueryHistoryRequest) (*HistoryEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HistoryEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowAPIService.QueryHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.offset == nil {
		return localVarReturnValue, nil, reportError("offset is required and must be specified")
	}
	if r.count == nil {
		return localVarReturnValue, nil, reportError("count is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	if r.sortColumn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortColumn", r.sortColumn, "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", r.sortOrder, "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.userIdentity != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userIdentity", r.userIdentity, "")
	}
	if r.sourceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sourceId", r.sourceId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowAPIScheduleComponentsRequest struct {
	ctx context.Context
	ApiService *FlowAPIService
	id string
	body *ScheduleComponentsEntity
}

// The request to schedule or unschedule. If the comopnents in the request are not specified, all authorized components will be considered.
func (r FlowAPIScheduleComponentsRequest) Body(body ScheduleComponentsEntity) FlowAPIScheduleComponentsRequest {
	r.body = &body
	return r
}

func (r FlowAPIScheduleComponentsRequest) Execute() (*ScheduleComponentsEntity, *http.Response, error) {
	return r.ApiService.ScheduleComponentsExecute(r)
}

/*
ScheduleComponents Schedule or unschedule components in the specified Process Group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The process group id.
 @return FlowAPIScheduleComponentsRequest
*/
func (a *FlowAPIService) ScheduleComponents(ctx context.Context, id string) FlowAPIScheduleComponentsRequest {
	return FlowAPIScheduleComponentsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ScheduleComponentsEntity
func (a *FlowAPIService) ScheduleComponentsExecute(r FlowAPIScheduleComponentsRequest) (*ScheduleComponentsEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ScheduleComponentsEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowAPIService.ScheduleComponents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/process-groups/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowAPISearchClusterRequest struct {
	ctx context.Context
	ApiService *FlowAPIService
	q *string
}

// Node address to search for.
func (r FlowAPISearchClusterRequest) Q(q string) FlowAPISearchClusterRequest {
	r.q = &q
	return r
}

func (r FlowAPISearchClusterRequest) Execute() (*ClusterSearchResultsEntity, *http.Response, error) {
	return r.ApiService.SearchClusterExecute(r)
}

/*
SearchCluster Searches the cluster for a node with the specified address

Note: This endpoint is subject to change as NiFi and it's REST API evolve.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FlowAPISearchClusterRequest
*/
func (a *FlowAPIService) SearchCluster(ctx context.Context) FlowAPISearchClusterRequest {
	return FlowAPISearchClusterRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ClusterSearchResultsEntity
func (a *FlowAPIService) SearchClusterExecute(r FlowAPISearchClusterRequest) (*ClusterSearchResultsEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ClusterSearchResultsEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowAPIService.SearchCluster")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/cluster/search-results"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.q == nil {
		return localVarReturnValue, nil, reportError("q is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowAPISearchFlowRequest struct {
	ctx context.Context
	ApiService *FlowAPIService
	q *string
	a *string
}

func (r FlowAPISearchFlowRequest) Q(q string) FlowAPISearchFlowRequest {
	r.q = &q
	return r
}

func (r FlowAPISearchFlowRequest) A(a string) FlowAPISearchFlowRequest {
	r.a = &a
	return r
}

func (r FlowAPISearchFlowRequest) Execute() (*SearchResultsEntity, *http.Response, error) {
	return r.ApiService.SearchFlowExecute(r)
}

/*
SearchFlow Performs a search against this NiFi using the specified search term

Only search results from authorized components will be returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FlowAPISearchFlowRequest
*/
func (a *FlowAPIService) SearchFlow(ctx context.Context) FlowAPISearchFlowRequest {
	return FlowAPISearchFlowRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SearchResultsEntity
func (a *FlowAPIService) SearchFlowExecute(r FlowAPISearchFlowRequest) (*SearchResultsEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SearchResultsEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowAPIService.SearchFlow")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/search-results"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.a != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "a", r.a, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
